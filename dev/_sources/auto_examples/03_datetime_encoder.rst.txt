
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/03_datetime_encoder.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_03_datetime_encoder.py>`
        to download the full example code or to run this example in your browser via JupyterLite or Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_03_datetime_encoder.py:


.. _example_datetime_encoder :

===================================================
Handling datetime features with the DatetimeEncoder
===================================================

In this example, we illustrate how to better integrate datetime features
in machine learning models with the |DatetimeEncoder|.

This encoder breaks down passed datetime features into relevant numerical
features, such as the month, the day of the week, the hour of the day, etc.

It is used by default in the |TableVectorizer|.


.. |DatetimeEncoder| replace::
    :class:`~skrub.DatetimeEncoder`

.. |TableVectorizer| replace::
    :class:`~skrub.TableVectorizer`

.. |OneHotEncoder| replace::
    :class:`~sklearn.preprocessing.OneHotEncoder`

.. |TimeSeriesSplit| replace::
    :class:`~sklearn.model_selection.TimeSeriesSplit`

.. |ColumnTransformer| replace::
    :class:`~sklearn.compose.ColumnTransformer`

.. |make_column_transformer| replace::
    :class:`~sklearn.compose.make_column_transformer`

.. |HGBR| replace::
    :class:`~sklearn.ensemble.HistGradientBoostingRegressor`

.. GENERATED FROM PYTHON SOURCE LINES 41-47

A problem with relevant datetime features
-----------------------------------------

We will use a dataset of air quality measurements in different cities.
In this setting, we want to predict the NO2 air concentration, based
on the location, date and time of measurement.

.. GENERATED FROM PYTHON SOURCE LINES 47-62

.. code-block:: Python


    from pprint import pprint

    import pandas as pd

    data = pd.read_csv(
        "https://raw.githubusercontent.com/pandas-dev/pandas"
        "/main/doc/data/air_quality_no2_long.csv"
    )
    # Extract our input data (X) and the target column (y)
    y = data["value"]
    X = data[["city", "date.utc"]]

    X






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }

        .dataframe tbody tr th {
            vertical-align: top;
        }

        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>city</th>
          <th>date.utc</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>Paris</td>
          <td>2019-06-21 00:00:00+00:00</td>
        </tr>
        <tr>
          <th>1</th>
          <td>Paris</td>
          <td>2019-06-20 23:00:00+00:00</td>
        </tr>
        <tr>
          <th>2</th>
          <td>Paris</td>
          <td>2019-06-20 22:00:00+00:00</td>
        </tr>
        <tr>
          <th>3</th>
          <td>Paris</td>
          <td>2019-06-20 21:00:00+00:00</td>
        </tr>
        <tr>
          <th>4</th>
          <td>Paris</td>
          <td>2019-06-20 20:00:00+00:00</td>
        </tr>
        <tr>
          <th>...</th>
          <td>...</td>
          <td>...</td>
        </tr>
        <tr>
          <th>2063</th>
          <td>London</td>
          <td>2019-05-07 06:00:00+00:00</td>
        </tr>
        <tr>
          <th>2064</th>
          <td>London</td>
          <td>2019-05-07 04:00:00+00:00</td>
        </tr>
        <tr>
          <th>2065</th>
          <td>London</td>
          <td>2019-05-07 03:00:00+00:00</td>
        </tr>
        <tr>
          <th>2066</th>
          <td>London</td>
          <td>2019-05-07 02:00:00+00:00</td>
        </tr>
        <tr>
          <th>2067</th>
          <td>London</td>
          <td>2019-05-07 01:00:00+00:00</td>
        </tr>
      </tbody>
    </table>
    <p>2068 rows Ã— 2 columns</p>
    </div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 63-74

Encoding the features
.....................

We will construct a |ColumnTransformer| in which we will encode
the city names with a |OneHotEncoder|, and the date
with a |DatetimeEncoder|.

During the instantiation of the |DatetimeEncoder|, we specify that we want
to extract the day of the week, and that we don't want to extract anything
finer than minutes. This is because we don't want to extract seconds and
lower units, as they are probably unimportant.

.. GENERATED FROM PYTHON SOURCE LINES 74-90

.. code-block:: Python


    from sklearn.preprocessing import OneHotEncoder

    from skrub import DatetimeEncoder

    from sklearn.compose import make_column_transformer

    encoder = make_column_transformer(
        (OneHotEncoder(handle_unknown="ignore"), ["city"]),
        (DatetimeEncoder(add_day_of_the_week=True, extract_until="minute"), ["date.utc"]),
        remainder="drop",
    )

    X_enc = encoder.fit_transform(X)
    pprint(encoder.get_feature_names_out())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    array(['onehotencoder__city_Antwerpen', 'onehotencoder__city_London',
           'onehotencoder__city_Paris', 'datetimeencoder__date.utc_month',
           'datetimeencoder__date.utc_day', 'datetimeencoder__date.utc_hour',
           'datetimeencoder__date.utc_dayofweek'], dtype=object)




.. GENERATED FROM PYTHON SOURCE LINES 91-97

We see that the encoder is working as expected: the "date.utc" column has
been replaced by features extracting the month, day, hour, and day of the
week information.

Note the year and minute features are not present, this is because they
have been removed by the encoder as they are constant the whole period.

.. GENERATED FROM PYTHON SOURCE LINES 99-104

One-liner with the |TableVectorizer|
....................................

As mentioned earlier, the |TableVectorizer| makes use of the
|DatetimeEncoder| by default.

.. GENERATED FROM PYTHON SOURCE LINES 104-111

.. code-block:: Python


    from skrub import TableVectorizer

    table_vec = TableVectorizer()
    table_vec.fit_transform(X)
    pprint(table_vec.get_feature_names_out())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ['date.utc_month',
     'date.utc_day',
     'date.utc_hour',
     'city_Antwerpen',
     'city_London',
     'city_Paris']




.. GENERATED FROM PYTHON SOURCE LINES 112-116

If we want to customize the |DatetimeEncoder| inside the |TableVectorizer|,
we can replace its default parameter with a new, custom instance:

Here, for example, we want it to extract the day of the week.

.. GENERATED FROM PYTHON SOURCE LINES 116-123

.. code-block:: Python


    table_vec = TableVectorizer(
        datetime_transformer=DatetimeEncoder(add_day_of_the_week=True),
    )
    table_vec.fit_transform(X)
    pprint(table_vec.get_feature_names_out())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ['date.utc_month',
     'date.utc_day',
     'date.utc_hour',
     'date.utc_dayofweek',
     'city_Antwerpen',
     'city_London',
     'city_Paris']




.. GENERATED FROM PYTHON SOURCE LINES 124-130

.. note:
    For more information on how to customize the |TableVectorizer|, see
    :ref:`sphx_glr_auto_examples_01_dirty_categories.py`.

Inspecting the |TableVectorizer| further, we can check that the
|DatetimeEncoder| is used on the correct column(s).

.. GENERATED FROM PYTHON SOURCE LINES 130-132

.. code-block:: Python

    pprint(table_vec.transformers_)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [('datetime', DatetimeEncoder(add_day_of_the_week=True), ['date.utc']),
     ('low_card_cat',
      OneHotEncoder(drop='if_binary', handle_unknown='infrequent_if_exist'),
      ['city'])]




.. GENERATED FROM PYTHON SOURCE LINES 133-147

Prediction with datetime features
---------------------------------

For prediction tasks, we recommend using the |TableVectorizer| inside a
pipeline, combined with a model that can use the features extracted by the
|DatetimeEncoder|.
Here's we'll use a |HGBR| as our learner.

.. note:
   You might need to require the experimental feature for scikit-learn
   versions earlier than 1.0 with:
   ```py
   from sklearn.experimental import enable_hist_gradient_boosting
   ```

.. GENERATED FROM PYTHON SOURCE LINES 147-157

.. code-block:: Python


    import numpy as np
    from sklearn.ensemble import HistGradientBoostingRegressor
    from sklearn.pipeline import make_pipeline

    table_vec = TableVectorizer(
        datetime_transformer=DatetimeEncoder(add_day_of_the_week=True),
    )
    pipeline = make_pipeline(table_vec, HistGradientBoostingRegressor())








.. GENERATED FROM PYTHON SOURCE LINES 158-167

Evaluating the model
....................

When using date and time features, we often care about predicting the future.
In this case, we have to be careful when evaluating our model, because
the standard settings of the cross-validation do not respect time ordering.

Instead, we can use the |TimeSeriesSplit|,
which ensures that the test set is always in the future.

.. GENERATED FROM PYTHON SOURCE LINES 167-182

.. code-block:: Python


    sorted_indices = np.argsort(X["date.utc"])
    X = X.iloc[sorted_indices]
    y = y.iloc[sorted_indices]

    from sklearn.model_selection import TimeSeriesSplit, cross_val_score

    cross_val_score(
        pipeline,
        X,
        y,
        scoring="neg_mean_squared_error",
        cv=TimeSeriesSplit(n_splits=5),
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([-120.29551054, -192.65273375, -170.69606296, -225.30467065,
           -214.21981371])



.. GENERATED FROM PYTHON SOURCE LINES 183-188

Plotting the prediction
.......................

The mean squared error is not obvious to interpret, so we compare
visually the prediction of our model with the actual values.

.. GENERATED FROM PYTHON SOURCE LINES 188-225

.. code-block:: Python


    import matplotlib.pyplot as plt
    from matplotlib.dates import AutoDateFormatter, AutoDateLocator

    X_train = X[X["date.utc"] < "2019-06-01"]
    X_test = X[X["date.utc"] >= "2019-06-01"]

    y_train = y[X["date.utc"] < "2019-06-01"]
    y_test = y[X["date.utc"] >= "2019-06-01"]

    pipeline.fit(X_train, y_train)

    all_cities = X_test["city"].unique()

    fig, axs = plt.subplots(nrows=len(all_cities), ncols=1, figsize=(12, 9))
    fig.subplots_adjust(hspace=0.5)

    for i, city in enumerate(all_cities):
        axs[i].plot(
            X.loc[X.city == city, "date.utc"],
            y.loc[X.city == city],
            label="Actual",
        )
        axs[i].plot(
            X_test.loc[X_test.city == city, "date.utc"],
            pipeline.predict(X_test.loc[X_test.city == city]),
            label="Predicted",
        )
        axs[i].set_title(city)
        axs[i].set_ylabel("NO2")
        xtick_locator = AutoDateLocator(maxticks=8)
        xtick_formatter = AutoDateFormatter(xtick_locator)
        axs[i].xaxis.set_major_locator(xtick_locator)
        axs[i].xaxis.set_major_formatter(xtick_formatter)
        axs[i].legend()
    plt.show()




.. image-sg:: /auto_examples/images/sphx_glr_03_datetime_encoder_001.png
   :alt: Paris, London, Antwerpen
   :srcset: /auto_examples/images/sphx_glr_03_datetime_encoder_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 226-227

Let's zoom on a few days:

.. GENERATED FROM PYTHON SOURCE LINES 227-264

.. code-block:: Python


    X_zoomed = X[(X["date.utc"] <= "2019-06-04") & (X["date.utc"] >= "2019-06-01")]
    y_zoomed = y[(X["date.utc"] <= "2019-06-04") & (X["date.utc"] >= "2019-06-01")]

    X_train_zoomed = X_zoomed[X_zoomed["date.utc"] < "2019-06-03"]
    X_test_zoomed = X_zoomed[X_zoomed["date.utc"] >= "2019-06-03"]

    y_train_zoomed = y[X["date.utc"] < "2019-06-03"]
    y_test_zoomed = y[X["date.utc"] >= "2019-06-03"]

    zoomed_cities = X_test_zoomed["city"].unique()

    fig, axs = plt.subplots(nrows=len(zoomed_cities), ncols=1, figsize=(12, 9))
    fig.subplots_adjust(hspace=0.5)

    for i, city in enumerate(zoomed_cities):
        axs[i].plot(
            X_zoomed.loc[X_zoomed["city"] == city, "date.utc"],
            y_zoomed.loc[X_zoomed["city"] == city],
            label="Actual",
        )
        axs[i].plot(
            X_test_zoomed.loc[X_test_zoomed["city"] == city, "date.utc"],
            pipeline.predict(X_test_zoomed.loc[X_test_zoomed["city"] == city]),
            label="Predicted",
        )
        axs[i].set_title(city)
        axs[i].set_ylabel("NO2")

        xtick_locator = AutoDateLocator(maxticks=8)
        xtick_formatter = AutoDateFormatter(xtick_locator)
        axs[i].xaxis.set_major_locator(xtick_locator)
        axs[i].xaxis.set_major_formatter(xtick_formatter)

        axs[i].legend()
    plt.show()




.. image-sg:: /auto_examples/images/sphx_glr_03_datetime_encoder_002.png
   :alt: London, Paris
   :srcset: /auto_examples/images/sphx_glr_03_datetime_encoder_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 265-273

Features importance
-------------------

Using the |DatetimeEncoder| allows us to better understand how the date
impacts the NO2 concentration. To this aim, we can compute the
importance of the features created by the |DatetimeEncoder|, using the
:func:`~sklearn.inspection.permutation_importance` function, which
basically shuffles a feature and sees how the model changes its prediction.

.. GENERATED FROM PYTHON SOURCE LINES 275-301

.. code-block:: Python

    from sklearn.inspection import permutation_importance

    table_vec = TableVectorizer(
        datetime_transformer=DatetimeEncoder(add_day_of_the_week=True),
    )

    # In this case, we don't use a pipeline, because we want to compute the
    # importance of the features created by the DatetimeEncoder
    X_ = table_vec.fit_transform(X)
    reg = HistGradientBoostingRegressor().fit(X_, y)
    result = permutation_importance(reg, X_, y, n_repeats=10, random_state=0)
    std = result.importances_std
    importances = result.importances_mean
    indices = np.argsort(importances)
    # Sort from least to most
    indices = list(reversed(indices))

    plt.figure(figsize=(12, 9))
    plt.title("Feature importances")
    n = len(indices)
    labels = np.array(table_vec.get_feature_names_out())[indices]
    plt.barh(range(n), importances[indices], color="b", yerr=std[indices])
    plt.yticks(range(n), labels, size=15)
    plt.tight_layout(pad=1)
    plt.show()




.. image-sg:: /auto_examples/images/sphx_glr_03_datetime_encoder_003.png
   :alt: Feature importances
   :srcset: /auto_examples/images/sphx_glr_03_datetime_encoder_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 302-312

We can see that the hour of the day is the most important feature,
which seems reasonable.

Conclusion
----------

In this example, we saw how to use the |DatetimeEncoder| to create
features from a date column.
Also check out the |TableVectorizer|, which automatically recognizes
and transforms datetime columns by default.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 4.547 seconds)


.. _sphx_glr_download_auto_examples_03_datetime_encoder.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: binder-badge

      .. image:: images/binder_badge_logo.svg
        :target: https://mybinder.org/v2/gh/skrub-data/skrub/main?urlpath=lab/tree/notebooks/auto_examples/03_datetime_encoder.ipynb
        :alt: Launch binder
        :width: 150 px

    .. container:: lite-badge

      .. image:: images/jupyterlite_badge_logo.svg
        :target: ../lite/lab/?path=auto_examples/03_datetime_encoder.ipynb
        :alt: Launch JupyterLite
        :width: 150 px

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: 03_datetime_encoder.ipynb <03_datetime_encoder.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: 03_datetime_encoder.py <03_datetime_encoder.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
