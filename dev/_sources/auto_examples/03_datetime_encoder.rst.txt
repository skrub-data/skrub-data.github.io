
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/03_datetime_encoder.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_03_datetime_encoder.py>`
        to download the full example code or to run this example in your browser via JupyterLite or Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_03_datetime_encoder.py:


.. _example_datetime_encoder :

===================================================
Handling datetime features with the DatetimeEncoder
===================================================

In this example, we illustrate how to better integrate datetime features
in machine learning models with the |DatetimeEncoder|.

This encoder breaks down passed datetime features into relevant numerical
features, such as the month, the day of the week, the hour of the day, etc.

It is used by default in the |TableVectorizer|.


.. |DatetimeEncoder| replace::
    :class:`~skrub.DatetimeEncoder`

.. |TableVectorizer| replace::
    :class:`~skrub.TableVectorizer`

.. |OneHotEncoder| replace::
    :class:`~sklearn.preprocessing.OneHotEncoder`

.. |TimeSeriesSplit| replace::
    :class:`~sklearn.model_selection.TimeSeriesSplit`

.. |ColumnTransformer| replace::
    :class:`~sklearn.compose.ColumnTransformer`

.. |make_column_transformer| replace::
    :class:`~sklearn.compose.make_column_transformer`

.. |HGBR| replace::
    :class:`~sklearn.ensemble.HistGradientBoostingRegressor`

.. |to_datetime| replace::
    :func:`~skrub.to_datetime`

.. GENERATED FROM PYTHON SOURCE LINES 44-50

A problem with relevant datetime features
-----------------------------------------

We will use a dataset of air quality measurements in different cities.
In this setting, we want to predict the NO2 air concentration, based
on the location, date and time of measurement.

.. GENERATED FROM PYTHON SOURCE LINES 50-64

.. code-block:: Python


    from pprint import pprint
    import pandas as pd

    data = pd.read_csv(
        "https://raw.githubusercontent.com/pandas-dev/pandas"
        "/main/doc/data/air_quality_no2_long.csv"
    ).sort_values("date.utc")
    # Extract our input data (X) and the target column (y)
    y = data["value"]
    X = data[["city", "date.utc"]]

    X






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }

        .dataframe tbody tr th {
            vertical-align: top;
        }

        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>city</th>
          <th>date.utc</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>2067</th>
          <td>London</td>
          <td>2019-05-07 01:00:00+00:00</td>
        </tr>
        <tr>
          <th>1098</th>
          <td>Antwerpen</td>
          <td>2019-05-07 01:00:00+00:00</td>
        </tr>
        <tr>
          <th>1003</th>
          <td>Paris</td>
          <td>2019-05-07 01:00:00+00:00</td>
        </tr>
        <tr>
          <th>1002</th>
          <td>Paris</td>
          <td>2019-05-07 02:00:00+00:00</td>
        </tr>
        <tr>
          <th>2066</th>
          <td>London</td>
          <td>2019-05-07 02:00:00+00:00</td>
        </tr>
        <tr>
          <th>...</th>
          <td>...</td>
          <td>...</td>
        </tr>
        <tr>
          <th>4</th>
          <td>Paris</td>
          <td>2019-06-20 20:00:00+00:00</td>
        </tr>
        <tr>
          <th>3</th>
          <td>Paris</td>
          <td>2019-06-20 21:00:00+00:00</td>
        </tr>
        <tr>
          <th>2</th>
          <td>Paris</td>
          <td>2019-06-20 22:00:00+00:00</td>
        </tr>
        <tr>
          <th>1</th>
          <td>Paris</td>
          <td>2019-06-20 23:00:00+00:00</td>
        </tr>
        <tr>
          <th>0</th>
          <td>Paris</td>
          <td>2019-06-21 00:00:00+00:00</td>
        </tr>
      </tbody>
    </table>
    <p>2068 rows Ã— 2 columns</p>
    </div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 65-67

We convert the dataframe date columns using |to_datetime|. Notice how
we don't need to specify the columns to convert.

.. GENERATED FROM PYTHON SOURCE LINES 67-72

.. code-block:: Python

    from skrub import to_datetime

    X = to_datetime(X)
    X.dtypes





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    city                     object
    date.utc    datetime64[ns, UTC]
    dtype: object



.. GENERATED FROM PYTHON SOURCE LINES 73-84

Encoding the features
.....................

We will construct a |ColumnTransformer| in which we will encode
the city names with a |OneHotEncoder|, and the date
with a |DatetimeEncoder|.

During the instantiation of the |DatetimeEncoder|, we specify that we want
to extract the day of the week, and that we don't want to extract anything
finer than minutes. This is because we don't want to extract seconds and
lower units, as they are probably unimportant.

.. GENERATED FROM PYTHON SOURCE LINES 84-98

.. code-block:: Python


    from sklearn.preprocessing import OneHotEncoder
    from sklearn.compose import make_column_transformer
    from skrub import DatetimeEncoder

    encoder = make_column_transformer(
        (OneHotEncoder(handle_unknown="ignore"), ["city"]),
        (DatetimeEncoder(add_day_of_the_week=True, resolution="minute"), ["date.utc"]),
        remainder="drop",
    )

    X_enc = encoder.fit_transform(X)
    pprint(encoder.get_feature_names_out())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    array(['onehotencoder__city_Antwerpen', 'onehotencoder__city_London',
           'onehotencoder__city_Paris', 'datetimeencoder__date.utc_year',
           'datetimeencoder__date.utc_month', 'datetimeencoder__date.utc_day',
           'datetimeencoder__date.utc_hour',
           'datetimeencoder__date.utc_minute',
           'datetimeencoder__date.utc_total_seconds',
           'datetimeencoder__date.utc_day_of_week'], dtype=object)




.. GENERATED FROM PYTHON SOURCE LINES 99-102

We see that the encoder is working as expected: the ``"date.utc"`` column has
been replaced by features extracting the month, day, hour, minute, day of the
week and total second since Epoch information.

.. GENERATED FROM PYTHON SOURCE LINES 104-109

One-liner with the |TableVectorizer|
....................................

As mentioned earlier, the |TableVectorizer| makes use of the
|DatetimeEncoder| by default.

.. GENERATED FROM PYTHON SOURCE LINES 109-115

.. code-block:: Python


    from skrub import TableVectorizer

    table_vec = TableVectorizer().fit(X)
    pprint(table_vec.get_feature_names_out())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    array(['date.utc_year', 'date.utc_month', 'date.utc_day', 'date.utc_hour',
           'date.utc_total_seconds', 'city_Antwerpen', 'city_London',
           'city_Paris'], dtype=object)




.. GENERATED FROM PYTHON SOURCE LINES 116-120

If we want to customize the |DatetimeEncoder| inside the |TableVectorizer|,
we can replace its default parameter with a new, custom instance:

Here, for example, we want it to extract the day of the week.

.. GENERATED FROM PYTHON SOURCE LINES 120-126

.. code-block:: Python


    table_vec = TableVectorizer(
        datetime_transformer=DatetimeEncoder(add_day_of_the_week=True),
    ).fit(X)
    pprint(table_vec.get_feature_names_out())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    array(['date.utc_year', 'date.utc_month', 'date.utc_day', 'date.utc_hour',
           'date.utc_total_seconds', 'date.utc_day_of_week', 'city_Antwerpen',
           'city_London', 'city_Paris'], dtype=object)




.. GENERATED FROM PYTHON SOURCE LINES 127-133

.. note:
    For more information on how to customize the |TableVectorizer|, see
    :ref:`sphx_glr_auto_examples_01_dirty_categories.py`.

Inspecting the |TableVectorizer| further, we can check that the
|DatetimeEncoder| is used on the correct column(s).

.. GENERATED FROM PYTHON SOURCE LINES 133-135

.. code-block:: Python

    pprint(table_vec.transformers_)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [('datetime', DatetimeEncoder(add_day_of_the_week=True), ['date.utc']),
     ('low_cardinality',
      OneHotEncoder(drop='if_binary', handle_unknown='ignore', sparse_output=False),
      ['city'])]




.. GENERATED FROM PYTHON SOURCE LINES 136-150

Prediction with datetime features
---------------------------------

For prediction tasks, we recommend using the |TableVectorizer| inside a
pipeline, combined with a model that can use the features extracted by the
|DatetimeEncoder|.
Here's we'll use a |HGBR| as our learner.

.. note:
   You might need to require the experimental feature for scikit-learn
   versions earlier than 1.0 with:
   ```py
   from sklearn.experimental import enable_hist_gradient_boosting
   ```

.. GENERATED FROM PYTHON SOURCE LINES 150-155

.. code-block:: Python

    from sklearn.ensemble import HistGradientBoostingRegressor
    from sklearn.pipeline import make_pipeline

    pipeline = make_pipeline(table_vec, HistGradientBoostingRegressor())








.. GENERATED FROM PYTHON SOURCE LINES 156-165

Evaluating the model
....................

When using date and time features, we often care about predicting the future.
In this case, we have to be careful when evaluating our model, because
the standard settings of the cross-validation do not respect time ordering.

Instead, we can use the |TimeSeriesSplit|,
which ensures that the test set is always in the future.

.. GENERATED FROM PYTHON SOURCE LINES 165-175

.. code-block:: Python

    from sklearn.model_selection import TimeSeriesSplit, cross_val_score

    cross_val_score(
        pipeline,
        X,
        y,
        scoring="neg_mean_squared_error",
        cv=TimeSeriesSplit(n_splits=5),
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([-108.89923208, -189.50744903, -181.15543923, -143.86698948,
           -207.90131453])



.. GENERATED FROM PYTHON SOURCE LINES 176-181

Plotting the prediction
.......................

The mean squared error is not obvious to interpret, so we compare
visually the prediction of our model with the actual values.

.. GENERATED FROM PYTHON SOURCE LINES 181-215

.. code-block:: Python

    import numpy as np
    import matplotlib.pyplot as plt

    mask_train = X["date.utc"] < "2019-06-01"
    X_train, X_test = X.loc[mask_train], X.loc[~mask_train]
    y_train, y_test = y.loc[mask_train], y.loc[~mask_train]

    pipeline.fit(X_train, y_train)
    y_pred = pipeline.predict(X_test)

    all_cities = X_test["city"].unique()

    fig, axes = plt.subplots(nrows=len(all_cities), ncols=1, figsize=(12, 9))
    for ax, city in zip(axes, all_cities):
        mask_prediction = X_test["city"] == city
        date_prediction = X_test.loc[mask_prediction]["date.utc"]
        y_prediction = y_pred[mask_prediction]

        mask_reference = X["city"] == city
        date_reference = X.loc[mask_reference]["date.utc"]
        y_reference = y[mask_reference]

        ax.plot(date_reference, y_reference, label="Actual")
        ax.plot(date_prediction, y_prediction, label="Predicted")

        ax.set(
            ylabel="NO2",
            title=city,
        )
        ax.legend()

    fig.subplots_adjust(hspace=0.5)
    plt.show()




.. image-sg:: /auto_examples/images/sphx_glr_03_datetime_encoder_001.png
   :alt: Paris, London, Antwerpen
   :srcset: /auto_examples/images/sphx_glr_03_datetime_encoder_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 216-217

Let's zoom on a few days:

.. GENERATED FROM PYTHON SOURCE LINES 217-246

.. code-block:: Python


    mask_zoom_reference = (X["date.utc"] >= "2019-06-01") & (X["date.utc"] < "2019-06-04")
    mask_zoom_prediction = (X_test["date.utc"] >= "2019-06-01") & (
        X_test["date.utc"] < "2019-06-04"
    )

    all_cities = ["Paris", "London"]
    fig, axes = plt.subplots(nrows=len(all_cities), ncols=1, figsize=(12, 9))
    for ax, city in zip(axes, all_cities):
        mask_prediction = (X_test["city"] == city) & mask_zoom_prediction
        date_prediction = X_test.loc[mask_prediction]["date.utc"]
        y_prediction = y_pred[mask_prediction]

        mask_reference = (X["city"] == city) & mask_zoom_reference
        date_reference = X.loc[mask_reference]["date.utc"]
        y_reference = y[mask_reference]

        ax.plot(date_reference, y_reference, label="Actual")
        ax.plot(date_prediction, y_prediction, label="Predicted")

        ax.set(
            ylabel="NO2",
            title=city,
        )
        ax.legend()

    plt.show()





.. image-sg:: /auto_examples/images/sphx_glr_03_datetime_encoder_002.png
   :alt: Paris, London
   :srcset: /auto_examples/images/sphx_glr_03_datetime_encoder_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 247-255

Features importance
-------------------

Using the |DatetimeEncoder| allows us to better understand how the date
impacts the NO2 concentration. To this aim, we can compute the
importance of the features created by the |DatetimeEncoder|, using the
:func:`~sklearn.inspection.permutation_importance` function, which
basically shuffles a feature and sees how the model changes its prediction.

.. GENERATED FROM PYTHON SOURCE LINES 257-284

.. code-block:: Python

    from sklearn.inspection import permutation_importance

    table_vec = TableVectorizer(
        datetime_transformer=DatetimeEncoder(add_day_of_the_week=True),
    )

    # In this case, we don't use a pipeline, because we want to compute the
    # importance of the features created by the DatetimeEncoder
    X_transform = table_vec.fit_transform(X)
    feature_names = table_vec.get_feature_names_out()

    model = HistGradientBoostingRegressor().fit(X_transform, y)
    result = permutation_importance(model, X_transform, y, n_repeats=10, random_state=0)

    result = pd.DataFrame(
        dict(
            feature_names=feature_names,
            std=result.importances_std,
            importances=result.importances_mean,
        )
    ).sort_values("importances", ascending=False)

    result.plot.barh(
        y="importances", x="feature_names", title="Feature Importances", figsize=(12, 9)
    )
    plt.tight_layout()




.. image-sg:: /auto_examples/images/sphx_glr_03_datetime_encoder_003.png
   :alt: Feature Importances
   :srcset: /auto_examples/images/sphx_glr_03_datetime_encoder_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 285-295

We can see that the total seconds since Epoch and the hour of the day
are the most important feature, which seems reasonable.

Conclusion
----------

In this example, we saw how to use the |DatetimeEncoder| to create
features from a date column.
Also check out the |TableVectorizer|, which automatically recognizes
and transforms datetime columns by default.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 4.550 seconds)


.. _sphx_glr_download_auto_examples_03_datetime_encoder.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: binder-badge

      .. image:: images/binder_badge_logo.svg
        :target: https://mybinder.org/v2/gh/skrub-data/skrub/0.1.0?urlpath=lab/tree/notebooks/auto_examples/03_datetime_encoder.ipynb
        :alt: Launch binder
        :width: 150 px

    .. container:: lite-badge

      .. image:: images/jupyterlite_badge_logo.svg
        :target: ../lite/lab/?path=auto_examples/03_datetime_encoder.ipynb
        :alt: Launch JupyterLite
        :width: 150 px

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: 03_datetime_encoder.ipynb <03_datetime_encoder.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: 03_datetime_encoder.py <03_datetime_encoder.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
