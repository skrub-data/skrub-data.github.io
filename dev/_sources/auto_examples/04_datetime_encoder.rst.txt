
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/04_datetime_encoder.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_04_datetime_encoder.py>`
        to download the full example code or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_04_datetime_encoder.py:


Handling datetime features with the DatetimeEncoder
===================================================

We illustrate here how to handle datetime features with the
DatetimeEncoder.

The DatetimeEncoder breaks down each datetime features into several
numerical features, by extracting relevant information from the datetime
features, such as the month, the day of the week, the hour of the day,
etc. Used in the SuperVectorizer, which automatically detects the
datetime features, the DatetimeEncoder allows to handle datetime features
easily.

.. GENERATED FROM PYTHON SOURCE LINES 15-19

.. code-block:: default


    import warnings
    warnings.filterwarnings("ignore")








.. GENERATED FROM PYTHON SOURCE LINES 20-24

**Data Importing**: We first fetch the dataset.

We want to predict the NO2 air concentration in different cities, based
on the date and the time of measurement.

.. GENERATED FROM PYTHON SOURCE LINES 24-31

.. code-block:: default

    import pandas as pd

    data = pd.read_csv("https://raw.githubusercontent.com/pandas-dev/pandas/main/doc/data/air_quality_no2_long.csv")
    y = data["value"]
    X = data[["city", "date.utc"]]
    X






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }

        .dataframe tbody tr th {
            vertical-align: top;
        }

        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>city</th>
          <th>date.utc</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>Paris</td>
          <td>2019-06-21 00:00:00+00:00</td>
        </tr>
        <tr>
          <th>1</th>
          <td>Paris</td>
          <td>2019-06-20 23:00:00+00:00</td>
        </tr>
        <tr>
          <th>2</th>
          <td>Paris</td>
          <td>2019-06-20 22:00:00+00:00</td>
        </tr>
        <tr>
          <th>3</th>
          <td>Paris</td>
          <td>2019-06-20 21:00:00+00:00</td>
        </tr>
        <tr>
          <th>4</th>
          <td>Paris</td>
          <td>2019-06-20 20:00:00+00:00</td>
        </tr>
        <tr>
          <th>...</th>
          <td>...</td>
          <td>...</td>
        </tr>
        <tr>
          <th>2063</th>
          <td>London</td>
          <td>2019-05-07 06:00:00+00:00</td>
        </tr>
        <tr>
          <th>2064</th>
          <td>London</td>
          <td>2019-05-07 04:00:00+00:00</td>
        </tr>
        <tr>
          <th>2065</th>
          <td>London</td>
          <td>2019-05-07 03:00:00+00:00</td>
        </tr>
        <tr>
          <th>2066</th>
          <td>London</td>
          <td>2019-05-07 02:00:00+00:00</td>
        </tr>
        <tr>
          <th>2067</th>
          <td>London</td>
          <td>2019-05-07 01:00:00+00:00</td>
        </tr>
      </tbody>
    </table>
    <p>2068 rows Ã— 2 columns</p>
    </div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 32-37

Encoding the data to numerical representations
-----------------------------------------------

Encoders for categorical and datetime features
..............................................

.. GENERATED FROM PYTHON SOURCE LINES 37-56

.. code-block:: default

    from sklearn.preprocessing import OneHotEncoder
    from dirty_cat import DatetimeEncoder

    cat_encoder = OneHotEncoder(handle_unknown="ignore")
    # We encode dates using the day of the week as it is probably relevant,
    # but no longer than minutes: we are probably not interested in seconds
    # and below
    datetime_encoder = DatetimeEncoder(add_day_of_the_week=True,
                                       extract_until="minute")

    from sklearn.compose import make_column_transformer

    datetime_columns = ["date.utc"]
    categorical_columns = ["city"]

    encoder = make_column_transformer((cat_encoder, categorical_columns),
                                      (datetime_encoder, datetime_columns),
                                      remainder="drop")








.. GENERATED FROM PYTHON SOURCE LINES 57-63

Transforming the input data
...........................
We can see that the encoder is working as expected: the date feature has
been replaced by features for the month, day, hour, and day of the week.
Note that the year and minute features have been removed by the encoder
because they are constant.

.. GENERATED FROM PYTHON SOURCE LINES 63-65

.. code-block:: default

    X_ = encoder.fit_transform(X)
    encoder.get_feature_names_out()




.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array(['onehotencoder__city_Antwerpen', 'onehotencoder__city_London',
           'onehotencoder__city_Paris', 'datetimeencoder__date.utc_month',
           'datetimeencoder__date.utc_day', 'datetimeencoder__date.utc_hour',
           'datetimeencoder__date.utc_dayofweek'], dtype=object)



.. GENERATED FROM PYTHON SOURCE LINES 66-68

.. code-block:: default

    X_





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([[ 0.,  0.,  1., ..., 21.,  0.,  4.],
           [ 0.,  0.,  1., ..., 20., 23.,  3.],
           [ 0.,  0.,  1., ..., 20., 22.,  3.],
           ...,
           [ 0.,  1.,  0., ...,  7.,  3.,  1.],
           [ 0.,  1.,  0., ...,  7.,  2.,  1.],
           [ 0.,  1.,  0., ...,  7.,  1.,  1.]])



.. GENERATED FROM PYTHON SOURCE LINES 69-73

One-liner with the SuperVectorizer
..................................
The DatetimeEncoder is used by default in the SuperVectorizer, which
automatically detects datetime features.

.. GENERATED FROM PYTHON SOURCE LINES 73-80

.. code-block:: default

    from dirty_cat import SuperVectorizer
    from pprint import pprint

    sup_vec = SuperVectorizer()
    sup_vec.fit_transform(X)
    pprint(sup_vec.get_feature_names_out())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ['date.utc_month',
     'date.utc_day',
     'date.utc_hour',
     'city_Antwerpen',
     'city_London',
     'city_Paris']




.. GENERATED FROM PYTHON SOURCE LINES 81-82

If we want the day of the week, we can just replace SuperVectorizer's default

.. GENERATED FROM PYTHON SOURCE LINES 82-88

.. code-block:: default

    sup_vec = SuperVectorizer(
            datetime_transformer=DatetimeEncoder(add_day_of_the_week=True),
        )
    sup_vec.fit_transform(X)
    sup_vec.get_feature_names_out()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    ['date.utc_month', 'date.utc_day', 'date.utc_hour', 'date.utc_dayofweek', 'city_Antwerpen', 'city_London', 'city_Paris']



.. GENERATED FROM PYTHON SOURCE LINES 89-91

We can see that the SuperVectorizer is indeed using
a DatetimeEncoder for the datetime features.

.. GENERATED FROM PYTHON SOURCE LINES 91-93

.. code-block:: default

    pprint(sup_vec.transformers_)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [('datetime', DatetimeEncoder(add_day_of_the_week=True), ['date.utc']),
     ('low_card_cat', OneHotEncoder(drop='if_binary'), ['city'])]




.. GENERATED FROM PYTHON SOURCE LINES 94-99

Predictions with date features
------------------------------
For prediction tasks, we recommend using the SuperVectorizer inside a
pipeline, combined with a model that uses the features extracted by the
DatetimeEncoder.

.. GENERATED FROM PYTHON SOURCE LINES 99-109

.. code-block:: default

    import numpy as np
    from sklearn.ensemble import HistGradientBoostingRegressor
    from sklearn.pipeline import make_pipeline

    sup_vec = SuperVectorizer(
            datetime_transformer=DatetimeEncoder(add_day_of_the_week=True),
        )
    reg = HistGradientBoostingRegressor()
    pipeline = make_pipeline(sup_vec, reg)








.. GENERATED FROM PYTHON SOURCE LINES 110-117

Evaluating the model
....................
When using date and time features, we often care about predicting the future.
In this case, we have to be careful when evaluating our model, because
standard tools like cross-validation do not respect the time ordering.
Instead, we can use the `TimeSeriesSplit` class, which makes sure that
the test set is always in the future.

.. GENERATED FROM PYTHON SOURCE LINES 117-127

.. code-block:: default

    X["date.utc"] = pd.to_datetime(X["date.utc"])
    sorted_indices = np.argsort(X["date.utc"])
    X = X.iloc[sorted_indices]
    y = y.iloc[sorted_indices]

    from sklearn.model_selection import TimeSeriesSplit, cross_val_score

    cross_val_score(pipeline, X, y, scoring="neg_mean_squared_error",
                    cv=TimeSeriesSplit(n_splits=5))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([-120.29551054, -192.65273375, -170.69606296, -225.30467065,
           -214.21981371])



.. GENERATED FROM PYTHON SOURCE LINES 128-132

Plotting the prediction
.......................
The mean squared error is not obvious to interpret, so we compare
visually the prediction of our model with the actual values.

.. GENERATED FROM PYTHON SOURCE LINES 132-158

.. code-block:: default

    import matplotlib.pyplot as plt
    from matplotlib.dates import ConciseDateFormatter

    X_train = X[X["date.utc"] < "2019-06-01"]
    X_test = X[X["date.utc"] >= "2019-06-01"]

    y_train = y[X["date.utc"] < "2019-06-01"]
    y_test = y[X["date.utc"] >= "2019-06-01"]

    pipeline.fit(X_train, y_train)
    fig, axs = plt.subplots(nrows=len(X_test.city.unique()), ncols=1,
                            figsize=(12, 9))

    for i, city in enumerate(X_test.city.unique()):
        axs[i].plot(X.loc[X.city == city, "date.utc"],
                    y.loc[X.city == city], label="Actual")
        axs[i].plot(X_test.loc[X_test.city == city, "date.utc"],
                    pipeline.predict(X_test.loc[X_test.city == city]),
                    label="Predicted")
        axs[i].set_title(city)
        axs[i].set_ylabel("NO2")
        axs[i].xaxis.set_major_formatter(
            ConciseDateFormatter(axs[i].xaxis.get_major_locator()))
        axs[i].legend()
    plt.show()




.. image-sg:: /auto_examples/images/sphx_glr_04_datetime_encoder_001.png
   :alt: Paris, London, Antwerpen
   :srcset: /auto_examples/images/sphx_glr_04_datetime_encoder_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 159-160

Let's zoom on a few days

.. GENERATED FROM PYTHON SOURCE LINES 160-187

.. code-block:: default


    X_zoomed = X[X["date.utc"] <= "2019-06-04"][X["date.utc"] >= "2019-06-01"]
    y_zoomed = y[X["date.utc"] <= "2019-06-04"][X["date.utc"] >= "2019-06-01"]

    X_train_zoomed = X_zoomed[X_zoomed["date.utc"] < "2019-06-03"]
    X_test_zoomed = X_zoomed[X_zoomed["date.utc"] >= "2019-06-03"]

    y_train_zoomed = y[X["date.utc"] < "2019-06-03"]
    y_test_zoomed = y[X["date.utc"] >= "2019-06-03"]

    pipeline.fit(X_train, y_train)
    fig, axs = plt.subplots(nrows=len(X_test_zoomed.city.unique()), ncols=1,
                            figsize=(12, 9))

    for i, city in enumerate(X_test_zoomed.city.unique()):
        axs[i].plot(X_zoomed.loc[X_zoomed.city == city, "date.utc"],
                    y_zoomed.loc[X_zoomed.city == city], label="Actual")
        axs[i].plot(X_test_zoomed.loc[X_test_zoomed.city == city, "date.utc"],
                    pipeline.predict(X_test_zoomed.loc[X_test_zoomed.city == city]),
                    label="Predicted")
        axs[i].set_title(city)
        axs[i].set_ylabel("NO2")
        axs[i].xaxis.set_major_formatter(
            ConciseDateFormatter(axs[i].xaxis.get_major_locator()))
        axs[i].legend()
    plt.show()




.. image-sg:: /auto_examples/images/sphx_glr_04_datetime_encoder_002.png
   :alt: London, Paris
   :srcset: /auto_examples/images/sphx_glr_04_datetime_encoder_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 188-195

Feature importances
-------------------
Using the DatetimeEncoder allows us to better understand how the date
impacts the NO2 concentration. To this aim, we can compute the
importance of the features created by the Datetime encoder, using the
`permutation_importance` function, which basically shuffles a feature
and sees how the model changes its prediction

.. GENERATED FROM PYTHON SOURCE LINES 197-223

.. code-block:: default

    from sklearn.inspection import permutation_importance

    sup_vec = SuperVectorizer(
            datetime_transformer=DatetimeEncoder(add_day_of_the_week=True),
        )

    # In this case, we don't use a pipeline, because we want to compute the
    # importance of the features created by the DatetimeEncoder
    X_ = sup_vec.fit_transform(X)
    reg = HistGradientBoostingRegressor().fit(X_, y)
    result = permutation_importance(reg, X_, y, n_repeats=10, random_state=0)
    std = result.importances_std
    importances = result.importances_mean
    indices = np.argsort(importances)
    # Sort from least to most
    indices = list(reversed(indices))

    plt.figure(figsize=(12, 9))
    plt.title("Feature importances")
    n = len(indices)
    labels = np.array(sup_vec.get_feature_names_out())[indices]
    plt.barh(range(n), importances[indices], color="b", yerr=std[indices])
    plt.yticks(range(n), labels, size=15)
    plt.tight_layout(pad=1)
    plt.show()




.. image-sg:: /auto_examples/images/sphx_glr_04_datetime_encoder_003.png
   :alt: Feature importances
   :srcset: /auto_examples/images/sphx_glr_04_datetime_encoder_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 224-226

We can see that the hour of the day is the most important feature,
which seems reasonable.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  3.779 seconds)


.. _sphx_glr_download_auto_examples_04_datetime_encoder.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: binder-badge

      .. image:: images/binder_badge_logo.svg
        :target: https://mybinder.org/v2/gh/dirty-cat/dirty-cat.github.io/master?filepath=dev/auto_examples/04_datetime_encoder.ipynb
        :alt: Launch binder
        :width: 150 px

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: 04_datetime_encoder.py <04_datetime_encoder.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: 04_datetime_encoder.ipynb <04_datetime_encoder.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
